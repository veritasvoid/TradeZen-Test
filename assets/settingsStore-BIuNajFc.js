import{D as E,E as b}from"./index-x_-wvZIm.js";const w={};function R(d,c){let s;try{s=d()}catch{return}return{getItem:a=>{var e;const v=h=>h===null?null:JSON.parse(h,void 0),m=(e=s.getItem(a))!=null?e:null;return m instanceof Promise?m.then(v):v(m)},setItem:(a,e)=>s.setItem(a,JSON.stringify(e,void 0)),removeItem:a=>s.removeItem(a)}}const I=d=>c=>{try{const s=d(c);return s instanceof Promise?s:{then(o){return I(o)(s)},catch(o){return this}}}catch(s){return{then(o){return this},catch(o){return I(o)(s)}}}},z=(d,c)=>(s,o,a)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,l)=>({...l,...r}),...c},v=!1;const m=new Set,h=new Set;let i;try{i=e.getStorage()}catch{}if(!i)return d((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},o,a);const y=I(e.serialize),p=()=>{const r=e.partialize({...o()});let l;const t=y({state:r,version:e.version}).then(u=>i.setItem(e.name,u)).catch(u=>{l=u});if(l)throw l;return t},S=a.setState;a.setState=(r,l)=>{S(r,l),p()};const g=d((...r)=>{s(...r),p()},o,a);let f;const n=()=>{var r;if(!i)return;v=!1,m.forEach(t=>t(o()));const l=((r=e.onRehydrateStorage)==null?void 0:r.call(e,o()))||void 0;return I(i.getItem.bind(i))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var u;return f=e.merge(t,(u=o())!=null?u:g),s(f,!0),p()}).then(()=>{l==null||l(f,void 0),v=!0,h.forEach(t=>t(f))}).catch(t=>{l==null||l(void 0,t)})};return a.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(i=r.getStorage())},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>n(),hasHydrated:()=>v,onHydrate:r=>(m.add(r),()=>{m.delete(r)}),onFinishHydration:r=>(h.add(r),()=>{h.delete(r)})},n(),f||g},F=(d,c)=>(s,o,a)=>{let e={storage:R(()=>localStorage),partialize:n=>n,version:0,merge:(n,r)=>({...r,...n}),...c},v=!1;const m=new Set,h=new Set;let i=e.storage;if(!i)return d((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...n)},o,a);const y=()=>{const n=e.partialize({...o()});return i.setItem(e.name,{state:n,version:e.version})},p=a.setState;a.setState=(n,r)=>{p(n,r),y()};const S=d((...n)=>{s(...n),y()},o,a);a.getInitialState=()=>S;let g;const f=()=>{var n,r;if(!i)return;v=!1,m.forEach(t=>{var u;return t((u=o())!=null?u:S)});const l=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(n=o())!=null?n:S))||void 0;return I(i.getItem.bind(i))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return[!0,e.migrate(t.state,t.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,t.state];return[!1,void 0]}).then(t=>{var u;const[_,H]=t;if(g=e.merge(H,(u=o())!=null?u:S),s(g,!0),_)return y()}).then(()=>{l==null||l(g,void 0),g=o(),v=!0,h.forEach(t=>t(g))}).catch(t=>{l==null||l(void 0,t)})};return a.persist={setOptions:n=>{e={...e,...n},n.storage&&(i=n.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>f(),hasHydrated:()=>v,onHydrate:n=>(m.add(n),()=>{m.delete(n)}),onFinishHydration:n=>(h.add(n),()=>{h.delete(n)})},e.skipHydration||f(),g||S},N=(d,c)=>"getStorage"in c||"serialize"in c||"deserialize"in c?((w?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),z(d,c)):F(d,c),J=N,L=E(J(d=>({settings:b,updateSettings:c=>{d(s=>({settings:{...s.settings,...c}}))},getCurrencySymbol:()=>L.getState().settings.currency}),{name:"tradezen-settings",version:1}));export{L as u};
